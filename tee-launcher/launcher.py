from collections import deque
import logging
import os
from typing import Dict
import requests
from subprocess import run
import sys
import time
import traceback
from dataclasses import dataclass

from requests.models import Response

# The volume where this file resides is shared between launcher and app.
# To avoid concurrent modifications, the launcher mounts the volume read-only!
# the contents of this file are generated by the node itself and fetched from the contract.
IMAGE_DIGEST_FILE = "/mnt/shared/image-digest"

# only considered if `IMAGE_DIGEST_FILE` does not exist.
ENV_VAR_DEFAULT_IMAGE_DIGEST = "DEFAULT_IMAGE_DIGEST"
# the timeout to use between rpc requests, in milliseconds
OS_ENV_VAR_RPC_TIMEOUT_MS = 'RPC_TIMEOUT_MS'

# MUST be set to 1.
OS_ENV_DOCKER_CONTENT_TRUST = 'DOCKER_CONTENT_TRUST'

# Dstack user configuration flags
DSTACK_USER_CONFIG_FILE = '/tapp/user_config'

# Dstack user config. Read from `DSTACK_USER_CONFIG_FILE`
USER_ENV_VAR_LAUNCHER_IMAGE_TAGS = 'LAUNCHER_IMAGE_TAGS'
USER_ENV_VAR_LAUNCHER_IMAGE_NAME = 'LAUNCHER_IMAGE_NAME'
USER_ENV_VAR_LAUNCHER_IMAGE_REGISTRY = 'LAUNCHER_REGISTRY'

# Default values for dstack user config file.
DEFAULT_LAUNCHER_IMAGE_NAME = 'nearone/mpc-node-gcp'
DEFAULT_REGISTRY = 'registry.hub.docker.com'
DEFAULT_LAUNCHER_IMAGE_TAG = 'latest'


def is_non_empty_and_cleaned(val: str) -> bool:
    if not isinstance(val, str):
        return False
    if not val.strip():
        return False
    return val.strip() == val


@dataclass(frozen=True)
class ImageSpec:
    tags: list[str]
    image_name: str
    registry: str

    def __post_init__(self):
        if not self.tags or not all(
                is_non_empty_and_cleaned(tag) for tag in self.tags):
            raise ValueError(
                "tags must be a non-empty list of non-empty strings without whitespaces."
            )

        if not is_non_empty_and_cleaned(self.image_name):
            raise ValueError(
                "image_name must be a non-empty string without whitespaces.")

        if not is_non_empty_and_cleaned(self.registry):
            raise ValueError(
                "registry must be a non-empty string without whitespaces.")


@dataclass(frozen=True)
class ResolvedImage:
    spec: ImageSpec
    digest: str

    def __post_init__(self):
        if not is_non_empty_and_cleaned(self.digest):
            raise ValueError(
                "image digest must be a non-empty string without whitespaces")
            # should we require specific lengths?

    def name(self) -> str:
        return self.spec.image_name

    def tags(self) -> list[str]:
        return self.spec.tags

    def registry(self) -> str:
        return self.spec.registry


def parse_env_file(path: str) -> dict[str, str]:
    '''
    Parse .env-style files.

    Provide implementation here to avoid external dependency.

    The returned key and value strings are stripped of whitespaces.
    '''
    env = {}
    with open(path) as f:
        for line in f:
            line = line.strip()
            if not line or line.startswith('#'):
                continue
            key, _, value = line.partition("=")
            env[key.strip()] = value.strip()
    return env


def get_image_spec(dstack_config: dict[str, str]) -> ImageSpec:
    tags_values: list[str] = dstack_config.get(
        USER_ENV_VAR_LAUNCHER_IMAGE_TAGS,
        DEFAULT_LAUNCHER_IMAGE_TAG).split(',')
    tags = [tag.strip() for tag in tags_values if tag.strip()]
    logging.info(f"Using tags {tags} to find matching image.")

    image_name: str = dstack_config.get(USER_ENV_VAR_LAUNCHER_IMAGE_NAME,
                                        DEFAULT_LAUNCHER_IMAGE_NAME)
    logging.info(f'Using image name {image_name}.')

    registry: str = dstack_config.get(USER_ENV_VAR_LAUNCHER_IMAGE_REGISTRY,
                                      DEFAULT_REGISTRY)
    logging.info(f'Using registry {registry}.')

    return ImageSpec(tags=tags, image_name=image_name, registry=registry)


def get_image_digest() -> str:
    if os.path.isfile(IMAGE_DIGEST_FILE):
        logging.info(f"opening image digest file {IMAGE_DIGEST_FILE}.")
        return open(IMAGE_DIGEST_FILE).readline().strip()
    else:
        logging.info(f'Using default image digest from environment.')
        return os.environ[ENV_VAR_DEFAULT_IMAGE_DIGEST].strip()


def main():

    logging.info(f'start')
    # We want to globally enable DOCKER_CONTENT_TRUST=1 to ensure integrity of Docker images.
    if os.environ.get(OS_ENV_DOCKER_CONTENT_TRUST, '0') != '1':
        raise RuntimeError(
            "Environment variable DOCKER_CONTENT_TRUST must be set to 1.")

    # In dstack, /tapp/user_config provides unmeasured data to the CVM.
    # We use this interface to make some aspects of the launcher configurable.
    # *** Only security-irrelevant parts *** may be made configurable in this way, e.g., the specific image tag(s) we look up.
    dstack_config: dict[str, str] = parse_env_file(
        DSTACK_USER_CONFIG_FILE) if os.path.isfile(
            DSTACK_USER_CONFIG_FILE) else {}

    image_digest = get_image_digest()
    logging.info(f'Using image digest {image_digest}.')
    image_spec = get_image_spec(dstack_config)
    docker_image = ResolvedImage(spec=image_spec, digest=image_digest)

    timeout_ms = int(os.environ.get(OS_ENV_VAR_RPC_TIMEOUT_MS, '500'))
    timeout_secs = timeout_ms / 1000.0
    manifest_digest = get_manifest_digest(docker_image, timeout_secs)

    name_and_digest = image_spec.image_name + "@" + manifest_digest

    proc = run(["docker", "pull", name_and_digest])

    if proc.returncode:
        raise RuntimeError("docker pull returned non-zero exit code %d" %
                           proc.returncode)

    proc = run([
        "docker", "image", "inspect", "--format", "{{index .ID}}",
        name_and_digest
    ],
               capture_output=True)

    if proc.returncode:
        raise RuntimeError(
            "docker image inspect returned non-zero exit code: %d" %
            proc.returncode)

    pulled_image_digest = proc.stdout.decode('utf-8').strip()

    if pulled_image_digest != image_digest:
        raise RuntimeError("Wrong image digest %s. Expected digest is %s" %
                           (pulled_image_digest, image_digest))

    # Generate a quote before extending RTMR3 with the image digest
    proc = run([
        'curl', '--unix-socket', '/var/run/dstack.sock', '-X', 'POST',
        'http://dstack/GetQuote', '-H', 'Content-Type: application/json', '-d',
        '{"report_data": ""}'
    ],
               capture_output=True)

    if proc.returncode:
        raise RuntimeError("getting quote failed with error code %d" %
                           proc.returncode)
    logging.info("Quote: %s" % proc.stdout.decode('utf-8').strip())

    # Python's requests package cannot natively talk HTTP over a unix socket (which is the API
    # exposed by dstack's guest agent). To avoid installing another Python depdendency, namely
    # requests-unixsocket, we just use curl.
    extend_rtmr3_json = '{"event": "mpc-image-digest","payload": "%s"}' % image_digest.split(
        ':')[1]
    proc = run([
        'curl', '--unix-socket', '/var/run/dstack.sock', '-X', 'POST',
        'http://dstack/EmitEvent', '-H', 'Content-Type: application/json',
        '-d', extend_rtmr3_json
    ])

    if proc.returncode:
        raise RuntimeError("extending rtmr3 failed with error code %d" %
                           proc.returncode)

    # Get quote after extending RTMR3 with the image digest
    proc = run([
        'curl', '--unix-socket', '/var/run/dstack.sock', '-X', 'POST',
        'http://dstack/GetQuote', '-H', 'Content-Type: application/json', '-d',
        '{"report_data": ""}'
    ],
               capture_output=True)

    if proc.returncode:
        raise RuntimeError("getting quote failed with error code %d" %
                           proc.returncode)

    logging.info("Quote: %s" % proc.stdout.decode('utf-8').strip())

    # Build the docker command we use to start the app, i.e., mpc node
    docker_cmd = ['docker', 'run']

    env_file = '/tapp/.host-shared/.user-config'
    if os.path.isfile(env_file):
        docker_cmd += ['--env-file', env_file]

    # hardcoded flags
    docker_cmd += [
        '-p',
        '11780:11780',  # TODO: adjust and / or make configurable according to `port_override` from the mpc node.
        '-v',
        '/tapp:/tapp:ro',
        '-v',
        '/var/run/dstack.sock:/var/run/dstack.sock',
        '-v',
        'shared-volume:/mnt/shared',
        '-v',
        'mpc-data:/data',
        # todo: remove these after testing [#535](https://github.com/near/mpc/issues/535)
        '--add-host',
        'mpc-node-0.service.mpc.consul:66.220.6.113',
        '--add-host',
        'mpc-node-1.service.mpc.consul:57.129.144.117',
        '--detach',
        image_digest
    ]

    logging.info("docker cmd %s", " ".join(docker_cmd))

    # Start the app.
    proc = run(docker_cmd)

    if proc.returncode:
        raise RuntimeError("docker run non-zero exit code %d", proc.returncode)


def request_until_success(url: str,
                          headers: Dict[str, str],
                          timeout_secs: float,
                          max_retries: int = 20) -> Response:
    """
    Repeatedly sends a GET request to the specified URL until a successful (200 OK) response is received.

    Args:
        url (str): The URL to request.
        headers (Dict[str, str]): Optional headers to include in the request.
        timeout (float): Time in seconds to wait between retries on failure.

    Returns:
        Response: The successful HTTP response object with status code 200.

    Notes:
        - Retries indefinitely until the request succeeds.
        - Prints a warning with the response content on each failure.
    """
    for attempt in range(1, max_retries):
        manifest_resp = requests.get(url, headers=headers)
        if manifest_resp.status_code != 200:
            print(
                f"[Warning] Attempt {attempt}/{max_retries}: Failed to fetch {url} for headers {headers}. "
                f"Status: {manifest_resp.text} {manifest_resp.headers}")
            time.sleep(timeout_secs)
            continue
        else:
            return manifest_resp

    raise RuntimeError(
        f"Failed to get succesful response from {url} after {max_retries} attempts."
    )


def get_manifest_digest(docker_image: ResolvedImage,
                        timeout_secs: float) -> str:
    '''
    Given an `image_digest` returns a manifest digest.

       `docker pull` requires a manifest digest. This function translates an image digest into a manifest digest by talking to the Docker registry.

       API doc for image registry https://distribution.github.io/distribution/spec/api/
    '''
    if not docker_image.tags():
        raise Exception(
            f"No tags found for image {docker_image.spec.image_name}")

    # We need an authorization token to fetch manifests.
    # TODO this still has the registry hard-coded in the url. also, if we use a different registry, we need a different auth-endpoint.
    token_resp = requests.get(
        f'https://auth.docker.io/token?service=registry.docker.io&scope=repository:{docker_image.name()}:pull'
    )
    token_resp.raise_for_status()
    token = token_resp.json().get('token', [])

    tags = deque(docker_image.tags())

    while tags:
        tag = tags.popleft()

        manifest_url = f"https://{docker_image.registry()}/v2/{docker_image.name()}/manifests/{tag}"
        headers = {
            "Accept": "application/vnd.docker.distribution.manifest.v2+json",
            "Authorization": f"Bearer {token}"
        }
        manifest_resp = request_until_success(manifest_url, headers,
                                              timeout_secs)
        manifest = manifest_resp.json()
        media_type = manifest['mediaType']
        if media_type == 'application/vnd.oci.image.index.v1+json':
            # Multi-platform manifest; we scan for amd64/linux images
            for image_manifest in manifest.get('manifests', []):
                platform = image_manifest.get('platform', [])
                if platform.get('architecture') == 'amd64' and platform.get(
                        'os') == 'linux':
                    tags.append(image_manifest['digest']
                                )  # are we sure this is what we want?
                    pass
        elif media_type in {
                'application/vnd.docker.distribution.manifest.v2+json',
                'application/vnd.oci.image.manifest.v1+json'
        }:
            config_digest = manifest['config']['digest']
            if config_digest == docker_image.digest:
                return manifest_resp.headers['Docker-Content-Digest']

    raise Exception("Image hash not found among tags.")


if __name__ == "__main__":
    try:
        logging.basicConfig(level=logging.INFO,
                            format='%(asctime)s [%(levelname)s] %(message)s')

        main()
        sys.exit(0)
    except Exception as e:
        print("Error:", str(e), file=sys.stderr)
        traceback.print_exc(file=sys.stderr)
        sys.exit(1)
