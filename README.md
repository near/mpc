# MPC

This repository contains the code for the Near MPC node. It is a rewrite of [Near MPC](https://github.com/near/mpc_old).

## How it works

There are two main parts of the binary: NEAR indexer and MPC signing.

### NEAR Indexer

The indexer is a NEAR node that tracks the shard where the signing smart contract lives (for mainnet, `v1.signer`). It monitors incoming requests by looking at successful calls to the `sign` function. Each request is hashed and mapped to a specific node in the MPC network — the *leader* for that request. The leader initiates the signing process and submits the final signature back to the smart contract. If the leader is offline, a secondary leader can take over.

### MPC Signing

The node supports multiple threshold signature schemes, organized into *domains*. Each domain has a unique ID, a signature scheme, and a purpose (signing, foreign-chain transactions, or confidential key derivation). All schemes share the same [FROST](https://eprint.iacr.org/2020/852)-based distributed key generation (DKG) but differ in their signing workflows.

#### Supported schemes

**OT-based ECDSA** (Secp256k1) — Originally derived from [Cait-Sith](https://github.com/cronokirby/cait-sith). Uses an offline phase with two protocols:
  - *Triple generation*: runs continuously in the background (target: up to 1M Beaver triples per node).
  - *Presignature generation*: also runs in the background; each presignature consumes two triples.
  - *Signing*: one round of communication using a presignature.

**Robust ECDSA** (Secp256k1) — Based on [DJNPO20](https://eprint.iacr.org/2020/501). Skips triple generation entirely:
  - *Presignature generation*: a single 3-round protocol using degree-2t polynomials.
  - *Signing*: one round, same as OT-based ECDSA.

**EdDSA** (Ed25519) — Based on [FROST](https://eprint.iacr.org/2020/852) threshold signatures:
  - *Presignature generation*: participants exchange nonce commitments.
  - *Signing*: one round using a presignature.

**Confidential Key Derivation** (BLS12-381) — Derives application-specific keys without revealing the master secret:
  - Takes an application ID and produces a derived key using oblivious transfer and Diffie-Hellman.

For each scheme, the participating set is fixed from the offline phase through to signature generation: if a presignature is generated by a specific set of participants, the resulting signature uses the same set.

## TEE Integration

Efforts are made to allow running MPC nodes inside a trusted execution environment (TEE). For more details, see the [TEE design doc](docs/securing-mpc-with-tee-design-doc.md).

## Dependencies and submodules

- **Nearcore Node**: This repository depends on the nearcore node, included as a submodule in the `/libs` directory.
- **Other Dependencies**: All other dependencies are handled by Cargo.

## Development Environment (Nix)

A Nix flake provides a reproducible development environment with the Rust toolchain, LLVM/Clang, NEAR CLI, and all system dependencies pre-configured. Run `nix develop` to enter the shell.

For setup details (direnv integration, VS Code config, verification), see [docs/nix-dev-environment.md](docs/nix-dev-environment.md).

## Compilation

This repository uses `rust-toolchain.toml` files, as some code sections may require specific compiler versions. Be aware of potential overrides from:

- Directory-specific toolchain overrides
- Environment variables

For more information, refer to the [Rustup book on overrides](https://rust-lang.github.io/rustup/overrides.html).

## Testing

### Terminology

We use the following terminology when referring to tests:
- _unit test_ -> a rust test in `/src` folder (per crate)
- _integration test_ -> a rust test in `/tests` folder (per crate)
- _system test_ -> a pytest in the `/pytest` folder

### Run tests

- **Unit and integration tests**: Run with `cargo test --profile test-release`
- **System Tests** : c.f. README located in the `/pytest` directory.

## Reproducible Builds

Both the node and launcher Docker images support reproducible builds, ensuring identical binaries from the same source. Run `./deployment/build-images.sh` from the project root.

For prerequisites and options, see [docs/reproducible-builds.md](docs/reproducible-builds.md).

## Releases

This project follows a standard release process with semantic versioning. Each release includes both the MPC node binary and the chain signatures contract as a single bundle.

For detailed information about our release process, compatibility guarantees, and procedures, see [RELEASES.md](RELEASES.md).

**Key Release Principles:**

- Releases are created from the `main` branch using semantic versioning.
- Minor versions maintain backward compatibility with previous node versions.
- Major versions ensure contract compatibility with the previous major version.

## Contributions

The NEAR MPC Node is actively maintained by **[NEAR One](https://github.com/Near-One)** and **[HOT Labs](https://github.com/hot-dao)** <img src="https://storage.herewallet.app/ft/1:hot.png" alt="HOT Labs" height="20" style="position: relative; top: 10px;"/>, with valuable contributions from the broader open-source community.

We welcome contributions in the form of issues, feature requests, and pull requests. Please ensure any changes are well-documented and tested. For major changes, open an issue to discuss the proposed modifications first.

### Development workflow

We run several checks in CI, which are backed by several tools not present by
default in rust developer environments:

- `cargo-nextest`
- `cargo-sort`
- `cargo-shear`
- `zizmor`
- `ruff`

This set does not include all checks, but only the most common reasons for CI
failures. Therefore, we suggest running these checks locally before opening a
PR. Running these checks with the correct parameters can be done easily with
`cargo-make`.

Running fast checks:

```console
cargo make check-all-fast
```

Running all `cargo-make` supported checks:

```console
cargo make check-all
```
